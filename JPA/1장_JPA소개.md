# 1.1 SQL을 직접 다를 때 발생하는 문제점

## 1.1.1 반복, 반복 그리고 반복
- 객체를 DB에 CRUD하려면 너무 많은 SQL과 JDBC API를 코드로 작성해야됨

## 1.1.2 SQL에 의존적인 개발
- 애플리케이션에서 SQL을 직접 다루면 발생하는 문제
  - 진정한 의미의 계층분할이 어려움
  - 엔티티를 신뢰할 수 없음
  - SQL에 의존적인 개발

## 1.1.3 JPA와 문제해결
> JPA가 제공하는 API 를 사용하면 알아서 적절한 SQL을 생성해서 DB에 전달
- persist() : insert sql 생성
- find() : select sql 생성
- JPA는 별도의 수정메소드가 없다. 
  - 객체를 조회해서 값을 변경하면 트랜잭션을 커밋할때 적절한 update sql 이 전달됨
- JPA는 연관된 객체를 사용하는 시점에 적절한 select sql 을 실행

# 1.2 패러다임의 불일치
> 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다르기 때문에 객체 구조를 테이블 구조에 저장하는데는 한계가 있다.

## 1.2.1 상속
> 객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다
- JDBC API
  - 부모 데이터에 대한 SQL, 자식 데이터에 대한 SQL 각각 따로 작성/처리 필요
- 패러다임의 불일치를 해결하려고 소모하는 비용임

### JPA와 상속
> JPA는 상속과 관련된 패러다임의 불일ㅇ치 문제를 개발자 대신 해결해준다

## 1.2.2 연관관계
> 연관관계를 가질때 객체는 참조를 사용, 테이블은 외래키를 사용
- 객체는 참조가 있는 방향으로만 조회 가능
- 테이블은 외래키 하나로 양쪽으로 모두 JOIN 가능 

### 객체를 테이블에 맞추어 모델링
- 외래 키까지 관계형 데이터베이스가 사용하는 방식에 맞추면 객체와 연관된 객체를 참조를 통해서 조회할 수 없다
- 좋은 객체 모델린은 기대하기 어렵고 결국 객체지향의 특징을 잃게됨

### 객체지향 모델링
- 객체지향 모델링을 사용하면 객체를 테이블에 저장하거나 조회하기가 쉽지않음
- 결국 개발자가 중간에서 변환역할을 해야함 -> 패러다임의 불일치를 해결하려고 소모하는 비용

### JPA와 연관관계
- 개발자는 객체간 관계를 설정하고 저장하면 된다
- JPA는 참조를 외래 키로 변환해서 적절한 INSERT SQL을 데이터베이스에 전달
- 객체를 조회할 때 외래키를 참조로 변환하는 일도 JPA가 처리해준다

## 1.2.3 객체 그래프 탐색
> SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다
- 객체지향 개발자에겐 너무 큰 제약
- 어디까지 객체 그래프 탐색이 가능한지 알아보려면 DAO를 열어서 SQL을 직접 확인해야됨
- 엔티티가 SQL에 논리적으로 종속되어서 발생하는 문제

### JPA와 객체 그래프 탐색
> JPA를 사용하면 객체 그래프를 마음껏 탐색할 수 있다
- 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미루는 지연로딩
- JPA는 연관된 객체를 즉시 함께 조회할지 아니면 실제 사용되는 시점에 조회할지를 간단하게 설정 가능

## 1.2.4 비교
- 테이블의 로우를 구분하는 방법과 객체르 ㄹ구분하는 방법에는 차이가 있다
  - 데이터베이스는 기본 키의 값으로 각 row를 구분
  - 객체는 identity와 equality 두가지 비교가 있음
- 같은 row에서 조회했더라도 다른 객체에 저장되면 객체 측면에서는 다른 인스턴스임

### JPA와 비교
> JPA는 같은 트랜잭션일 때 같은 객체가 조회되는것을 보장

## 1.2.5 정리
> 객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다르다

# 1.3 JPA란 무엇인가?
- JPA(Java Persistence API) : 자바 진영의 ORM 기술 표준이다
- ORM(Object-Relational Mapping) : 객체와 관계형 데이터베이스를 매핑한다는 뜻
- ORM 프레임워크는 SQL을 개발자 대신 생성해서 데이터베이스에 전달해줌
- 다양한 패러다임의 불일치 문제들도 해결해줌

## 1.3.1 JPA 소개
- 엔터프라이즈 자바 빈즈(EJB) 라는 기술표준에 엔티티 빈 이라는 ORM 기술도 있었음.
  - 너무 복잡하고 기술 성숙도가 떨어짐
  - J2EE 앱서버에서만 동작
- EJB 3.0에서 하이버네이트 기반으로 새로운 자바 ORM 기술 표준이 만들어짐 -> JPA
- JPA는 자바 ORM 기술에 대한 API 표준 명세
  - 인터페이스를 모아둔 것

## 1.3.2 왜 JPA를 사용해야 하는가?
- 생산성
  - 지루하고 반복적인 코드와 CRUD용 SQL을 개발자가 직접 작성하지 않아도 된다
  - 데이터베이스 설계중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.
- 유지보수
  - 필드를 추가하거나 삭제해도 수정해야 할 코드가 줄어든다
  - 유지보수하기 좋은 도메인 모델을 편리하게 설계할 수 있다
- 패러다임의 불일치 해결
- 성능
  - JPA는 앱과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공한다
  - 앱과 데이터베이스 사이에 계층이 하나 더 있으면 최적화 관점에서 시도해 볼 수 있는 것들이 많다
- 데이터 접근 추상화와 벤더 독립성
  - JPA는 앱과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공한다
  - 앱이 특정 데이터베이스 기술에 족속되지 않도록 해줌.
- 표준
  - JPA는 자바 진영의 ORM 기술 표준이다
  - 표준을 사용하면 다른 구현 기술로 손쉽게 변경할 수 있다

# 1.4 Q&A
- 매우 복잡한 SQL은 어떡하나?
  - JPA는 통계 쿼리 같이 복잡한 쿼리보다는 실시간 처리용 쿼리에 더 최적화
  - 마이바티스나 스프링의 JdbcTemplate 같은 SQL 매퍼 형태의 프레임워크를 혼용하는것도 좋은 방법



