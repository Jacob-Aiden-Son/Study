# 3.1 엔티티 매니저 팩토리와 엔티티 매니저

- EntityManagerFactory
  - 데이터베이스를 하나만 사용하는 앱은 일반적으로 EntityManagerFactory를 하나만 생성
  - `Persistence.createEntityManagerFactory("persistence-unit name")` 를 호출하면 META-INF/persistence.xml에 있는 정보를 바탕으로 EntityManagerFactory 생성
  - 필요할때마다 팩토리에서 매니저 생성하면 됨
  - 여러 스레드가 동시에 접근해도 안전
- EntityManager
  - 여러 스레드가 동시에 접근하면 동시성 문제 발생. 절대 공유금지
  - 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않음.
    - 보통 트랜잭션을 시작할때 획득
  - J2EE 환경에서는 해당 컨테이너가 제공하는 데이터소스로 커넥션풀 생성

# 3.2 영속성 컨텍스트란?
- `persist()` 메소드는 엔티티 매니저를 사용해서 엔티티를 영속성 컨텍스트에 저장
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다
  - 하나의 컨텍스트를 여러 매니저가 접근가능하지만 이건 나중에 다룸

# 3.3 엔티티의 생명주기
- 비영속
  - 아직 저장하지 않은 상태
  - 영속성 컨텍스트나 데이터베이스와 전혀 관련없음
- 영속
  - 영속성 컨텍스트에 저장된 상태
  - 영속상태 = 영속성 컨텍스트에 의해 관리됨
- 준영속
  - 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지않게됨
- 삭제
  - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제

# 3.4 영속성 컨텍스트의 특징
- 영속성 컨텍스트와 식별자 값
  - 영속 상태는 식별자 값(`@id`로 매핑한 값)이 반드시 있어야 한다
- 영속성 컨텍스트와 데이터베이스 저장
  - 보통 트랜잭션을 커밋할때 저장 = 플러시(flush)
- 영속성 컨텍스트가 엔티티를 관리할 때 장점
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기지연
  - 변경감지
  - 지연로딩

## 3.4.1 엔티티 조회
- 영속성 컨텍스트 내부의 캐시를 "1차 캐시"라 한다. 
- 키는 데이터베이스 기본키와 매핑된 식별자 값
- 영속성 컨텍스트에 저장하고 조회하는건 모두 데이터베이스 기본 키 값

### 1차 캐시에서 조회
- `find()`를 호출하면 우선 1차 캐시에서 식별자 값으로 엔티티 찾음
- 엔티티가 있으면 데이터베이스 조회하지 않고 메모리에 있는 1차캐시에서 조회

### 데이터베이스에서 조회
- `find()`를 호출했는데 1차 캐시에 없는경우 데이터베이스를 조회해서 엔티티 생성
- 1차 캐시에 생성된 엔티티 저장 후 영속 상태의 엔티티 반환

### 영속 엔티티의 동일성 보장
- 동일한 `find()`를 반복해서 호출해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환
- 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다

## 3.4.2 엔티티 등록
- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지않고 내부 쿼리 저장소에 SQL을 모은다
- 트랜잭션 커밋할 때 모아둔 쿼리를 데이터베이스에 보냄 (쓰기 지연)

### 트랜잭션을 지원하는 쓰기 지연이 가능한 이유
- 트랜잭션 범위 안에서 실행되므로 어떻게든 커밋 직전에만 데이터베이스에 SQL을 전달하면 된다

## 3.4.3 엔티티 수정
### SQL 수정 쿼리의 문제점
- 수정 쿼리가 상황에 따라 많아지기도 함
- 비즈니스 로직을 분석하기 위해 SQL을 계속 확인해야함
- 직접적이든 간접적이든 비즈니스 로직이 SQL에 의존

### 변경감지
- JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다
- 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경감지라고 함
- 스냅샷 : JPA에서 엔티티를 영속성 컨텍스트에 보관할 때 최초상태를 복사해서 저장해두는것
- 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다
- 변경 감지는 영속 상태의 엔티티에만 적용됨
- 모든 필드를 업데이트
  - 수정쿼리가 항상 같다
  - 앱 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용 가능
  - 데이터베이스는 이전에 파싱된 쿼리 재사용 가능

## 3.4.4 엔티티 삭제
- 엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야함
- `remove()` 호출하는 순간 영속성 컨텍스트에서 제거됨
- 삭제된 엔티티는 재사용하지 말고 자연스럽게 가비지 컬렉션의 대상이 되도록 두는 것이 좋음

# 3.5 플러시
> 플러시(`flush()`)는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는 것

- 직접호출
  - 테스트나 다른 프레임워크와JPA를 함께 사용할 때를 제외하고 거의 사용하지 않음
- 트랜잭션 커밋 시 플러시 자동 호출
  - 트랜잭션을 커밋할 때 플러시를 자동으로 호출
- JPQL 쿼리 실행 시 플러시 자동 호출
  - JPQL은 SQL로 변환되어 데이터베이스에서 엔티티를 조회하기 때문에 변경내용이 데이터베이스에 반영되어있어야함
  - 쿼리를 실행하기 직전에 영속성 컨텍스트를 플러시

## 3.5.1 플러시 모드 옵션
- FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시 (기본값)
- FlushModeType.COMMIT : 커밋할 때만 플러시

# 3.6 준영속
- 영속 상태의 엔티티가 영속 컨텍스트에서 분리된 것을 준영속 상태라 함
- 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없음

## 3.6.1 엔티티를 준영속 상태로 전환: detach()
- 이 메소드를 호출하는 순간 1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거됨
- 준영속 상태는 영속성 컨텍스트로부터 분리(detach)된 상태다

## 3.6.2 영속성 컨텍스트 초기화: clear()
- `clear()`는 영속성 컨테스트를 초기화해서 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만든다
- 영속성 컨텍스트를 제거하고 새로 만든 것과 같다

## 3.6.3 영속성 컨텍스트 종료: close()
- 영속성 컨텍스트를 종료하면 해당 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모두 준영속 상태가 된다

## 3.6.4 준영속 상태의 특징
- 거의 비영속 상태에 가깝다
  - 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않음
- 식별자 값을 가지고 있다
  - 비영속은 식별자 값이 없을 수 있지만 준영속은 한번 영속 상태였기 때문에 반드시 식별자 값을 가지고 있다
- 지연로딩을 할 수 없다

## 3.6.5 병합: merge()
- 새로운 영속 상태의 엔티티를 반환
### 준영속 병합
- 준영속 상태인 엔티티와 merge 후 영속 상태인 엔티티는 서로 다른 인스턴스
- 준영속 상태인 엔티티는 사용할 필요가 없기 때문에 준영속 엔티티를 참조하던 변수를 영속 엔티티를 참조하도록 변경하는것이 안전
```java
Member mergeMember = em.merge(member); // X
member = em.merge(member) // O
```
### 비영속 병합
- 병합은 준영속, 비영속을 신경 쓰지 않음
- 식별자 값으로 엔티티를 조회할 수 있으면 불러서 병합, 없으면 새로 생성해서 병합
- 병합은 save or update 기능을 수행

# 3.7 정리
- 엔티티 매니저는 엔티티 매니저 팩토리에서 생성
- 영속성 컨텍스트는 앱과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할
- 영속성 컨텍스트레 저장한 엔티티는 플러시 시점에 데이터베이스에 반영
  - 일반적으로 트랜잭션 커밋시 플러시
- 준영속 : 영속성 컨텍스트가 해당 엔티티를 더 이상 관리하지 못하는 상태
  - 1차 캐시, 동일성 보장, 트랜잭션 지원 쓰기지연, 변경감지, 지연로딩 같은 기능 사용못함